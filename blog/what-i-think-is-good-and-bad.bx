<?xml version='1.0' encoding='utf-8'?>
<blog>
<entry when='20200524T072300'>
<title>What I think is good and bad</title>
<category>python</category>
<category>irc</category>
<body>

<p>I'm in the #python IRC channel on Freenode a lot.  The people there are often
quite opinionated. <a href="https://github.com/Julian">Julian</a> had the idea
of processing the logs to see what we thought was good, and what was bad, using
sophisticated sentiment analysis.</p>

<p>Finding out what I liked and didn't like wasn't hard, since the
"sophisticated sentiment analysis" was two regexes:
"&lt;nedbat>.* is good" and "&lt;nedbat>.* is bad"!</p>

<p>Without further commentary, here is a sampling of things that I said were bad:</p>

<ul>
<li>vertical alignment is bad because it means you might have to change many lines just because one of them got wider.</li>
<li>eval(input()) is bad.</li>
<li>blindly following stuff is bad.</li>
<li>trolling is bad.  Find a way to use your brains for good.</li>
<li>floats for currency is bad.</li>
<li>any class that you can only instantiate once is bad.</li>
<li>that sounds like a singleton, which is bad.</li>
<li>some people say, "you should start by learning assembler," and i think that is bad advice.</li>
<li>del is fine. __del__ is bad</li>
<li>implicit copying is bad</li>
<li>texture (repetition you can see when you squint) is bad in code</li>
<li>aligning indents with the opening delimiter is bad.</li>
<li>this is bad: def main(nums=[1,2,3]).</li>
<li>monkeypatching is bad</li>
<li>it is bad to modify a list you are iterating.</li>
<li>__import__ is bad</li>
<li>import * is bad stuff</li>
<li>the python doc search is bad</li>
<li>and-or is bad</li>
<li>singletons are hidden global state, and global state is bad</li>
<li>checking types is bad</li>
<li>that ":type myparam:"  syntax is bad, it's not readable. use google style instead: <a href="https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html#google-vs-numpy">https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html#google-vs-numpy</a></li>
<li>python is bad at recursion deeper than 1000</li>
<li>there is a package on pypi called time, which is bad.</li>
</ul>

<p>And here are some things I said were good:</p>

<ul>
<li>"python -m app_name" is good, but recent.</li>
<li>endswith is good</li>
<li>xpath is good at selecting nodes in an xml dom tree.</li>
<li>recursion is good for recursive structures. Iteration is good for iterative structures</li>
<li>madlibs is good because you can do string manipulation with puerile humor</li>
<li>learning is good! :)</li>
<li>python is good for full applications.</li>
<li>re.sub is good.</li>
<li>mock(spec=thing) is good</li>
<li>excitement is good :)</li>
<li>pip will know how to install into virtualenvs, which is good.</li>
<li>gist.github.com is good</li>
<li>argparse is good for simple things</li>
<li>it is good to cover your tests, though others disagree with me</li>
<li>textwrap.dedent is good</li>
<li>requirements.txt is good for recreating environments.</li>
<li>the csv module is good at writing out dicts as rows.</li>
<li>this is good for seeing how rst will be formatted: <a href="http://rst.ninjs.org/">http://rst.ninjs.org/</a></li>
<li>colorama is good</li>
<li>yaml is good</li>
<li>setUp is good.  tearDown is better done as addCleanup</li>
<li>yield from is good for when you want one generator to produce all the values from another generator.</li>
<li>duck typing is good when there's an operation supported across a number of types, and you can just use the operation without worrying about the type.</li>
<li>learning is good! :)</li>
<li>Django is good if you like having lots of things handled for you.  Flask is good if you like to put together all the pieces yourself.</li>
<li>tox is good for testing against multiple environments</li>
<li>for validating email addresses, this is good:  [^@ ]+@[^@ ]+\.[^@ ]+ <a href="https://nedbatchelder.com/blog/200908/humane_email_validation.html">https://nedbatchelder.com/blog/200908/humane_email_validation.html</a></li>
<li>the python.org tutorial is good if you have programmed in other languages before.</li>
<li>"pip install -e ."  is good</li>
<li>the interactive interpreter is good for experimentation, but isn't good for real development.</li>
<li>bpaste.net is good</li>
<li>Think Python is good</li>
<li>atexit is good.</li>
<li>python is good, and we are helpful and friendly :)</li>
<li>pandas is good if you need to manipulate tables of data. If you don't, then don't use pandas</li>
<li>you want to do something for each thing in a list, that's what a for loop is good for :)</li>
<li>there's an old habit of using ":type:blah:" or whatever, which is horrible. Sphinx now supports the "napoleon" style natively, which is good: <a href="http://www.sphinx-doc.org/en/1.4.8/ext/napoleon.html">http://www.sphinx-doc.org/en/1.4.8/ext/napoleon.html</a></li>
<li>pytest does cool assert rewriting, which 99.9999% of the time is good magic.</li>
<li>pudb is good in the terminal</li>
<li>trying to be efficient is good.</li>
<li>sql is good for some kinds of data. nosql is good for others.</li>
<li>.format is good</li>
<li>a decorator is good for wrapping functions in new functionality.</li>
<li>the pytest -k option is good at that.</li>
<li>i would not try to jam everything into setup.py.  this feels like something a makefile is good at.</li>
<li>pytest is good at parameterized tests.</li>
<li>"if not list:" is good python</li>
<li>@classmethod is good for alternate constructors, yes.</li>
<li>rg is good: <a href="https://github.com/BurntSushi/ripgrep">https://github.com/BurntSushi/ripgrep</a></li>
<li>the prompt is good for doing small experiments.  Once you have larger programs, put them in .py files, and run them:  python myprog.py</li>
<li>low tech is good tech</li>
<li>Learning is good.</li>
<li>numpy is good when you can do whole-matrix operations at once.  If you need to iterate over elements and do individual operations, it doesn't provide any benefit.</li>
<li>any is good when you have an iterable of true/false</li>
<li>choice is good. Why should there be only one implementation?</li>
<li>gist.github.com is good, or paste.pound-python.org</li>
<li>click is good</li>
<li>you're not using a shell, which is good.</li>
<li>whatever helps you learn is good</li>
<li>numpy is good when you are doing matrix and array operations. lists are good for ordered collections of things</li>
<li>obfuscation isn't something Python is good at.</li>
<li>the ast module is good for one thing: representing python programs as a tree of nodes. It provides tools for parsing source text into that tree.</li>
<li>python is good as a first language</li>
<li>isolation is good, but doing it with mocks can be a problem in itself</li>
<li>subclassing is good for when SubClass, by its essence is a ParentClass.</li>
<li>talking is good :)</li>
<li>coverage.py is good.</li>
<li>recursion is good for recursive structures (trees).  iteration is better for linear structures (lists)</li>
<li>Jupyter is good for visualizations, graphing, tables, etc. interactive experimentation</li>
<li>lxml.html is good</li>
<li>sha256 is good too</li>
<li>Fluent Python is good, if you like books</li>
<li>for speed, PyPy is good.  Or Cython.  if you want to write C code, you can use cffi to call it from Python</li>
<li>curiosity is good</li>
<li>collections.Counter is good at counting things, and would do this in O(N).</li>
<li>.encode makes the conversion explicit, which is good.  my_bytes = my_unicode.encode("utf8")</li>
<li>they is good.</li>
<li>pudb is good</li>
<li>in python 3, super() is good, but it doesn't work in python 2.</li>
<li>the -k option is good for this, or you can define markers.</li>
<li>virtualenv is good for separating different projects' needs</li>
<li>tig is good too</li>
<li>rst is good at multi-page docs, without assuming it will be html.  markdown just shrugs and says, "use html when you have to"</li>
<li>writing is good just for its own sake.</li>
<li>bpaste.net is good.</li>
<li>learning is good</li>
<li>dependencies are good. using other people's solutions to your problems is good.</li>
<li>split has a much better PR agency, but partition is good too</li>
<li>attribute access is good.</li>
<li>i won't say that loops should introduce scopes, but it is good to be able to understand the interplay between scoping and closur-ing</li>
<li>https://pypi.org/project/appdirs/ is good for answering that question</li>
<li>automate the boring stuff is good.  What kind of software will you be writing?</li>
<li>iso8601 is good</li>
<li>prompt_toolkit is good</li>
<li>numpy is good when you have an array full of data, and you can do one operation that works on all of it at once</li>
</ul>

</body>
</entry>
</blog>
