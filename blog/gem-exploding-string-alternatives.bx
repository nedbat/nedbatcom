<?xml version='1.0' encoding='utf-8'?>
<blog>
<entry when='20211224T123429' draft='y'>
<title>Gem: exploding string alternatives</title>
<category>python</category>
<category>gem</category>
<!--
<description></description>
<img src="pix/cards/xxx.png" alt=""/>
-->
<body>

<p>Here's a Python gem: a function to list string generated by a pattern with
embedded alternatives.  It takes an input string with brace-wrapped
possibilities, and produces all the strings made from making choices among them.
</p>

<p>An input string like:</p>

<code><![CDATA[
"Then {Alice,Bob} ate a {banana,donut}."
]]></code>

<p>would produce four strings:</p>

<code><![CDATA[
"Then Alice ate a banana."
"Then Alice ate a donut."
"Then Bob ate a banana."
"Then Bob ate a donut."
]]></code>

<p>Here's the function:</p>

<code lang="python"><![CDATA[
def explode(pattern: str) -> Iterable[str]:
    """
    Expand the brace-delimited possibilities in a string.
    """
    seg_choices = []
    for segment in re.split(r"(\{.*?\})", pattern):
        if segment.startswith("{"):
            seg_choices.append(p.strip("{}").split(","))
        else:
            seg_choices.append([p])

    for parts in itertools.product(*seg_choices):
        yield "".join(parts)
]]></code>

<p>I call this a gem because it's concise without being tricky, and uses
Python's tools to strong effect. Let's look at how it works.</p>

<p><b>re.split</b>: The first step is to break the string into pieces.  I used
<a href="https://docs.python.org/3/library/re.html#re.split">re.split()</a>:
it takes a regular expression, divides the string wherever the pattern matches,
and returns a list of parts.</p>

<p>A subtlety that I make use of here: if the splitting regex has capturing
groups (parenthesized pieces), then those captured strings are also included in
the result list.  The pattern is anything enclosed in curly braces, and I've
parenthesized the whole thing so that I'll get those bracketed pieces in the
split list.</p>

<p>For our sample string, re.split will return these segments:</p>

<code><![CDATA[
['Then ', '{Alice,Bob}', ' ate a ', '{banana,donut}', '.']
]]></code>

<p><b>Grouping</b>: I used that list of segments to make another list, the
choices for each segment.  If a segment starts with a brace, then I strip off
the braces and split on commas to get a list of the alternatives.  The segments
that don't start with a brace are the non-choices part of the string, so I add
them as a one-choice list. This gives us a uniform list of lists, where the
inner lists are the choices for each segment of the result.</p>

<p>For our sample string, this is the parts list:</p>

<code lang="python"><![CDATA[
[['Then '], ['Alice', 'Bob'], [' ate a '], ['banana', 'donut'], ['.']]
]]></code>

<p><b>itertools.product</b>: To generate all the combinations, I used
<a href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product()</a>,
which does much of the heavy lifting of this function.  It takes a number of
iterables as arguments and generates all the different combinations of choosing
one element from each.  My seg_choices list is exactly the list of arguments
needed for itertools.product, and I can apply it with the star syntax.</p>

<p>The values from itertools.product are tuples of the choices made. The last
step is to join them together and use yield to provide the value to the
caller.</p>


</body>
</entry>
</blog>
